# Left-RecursionEliminator

**This project was made by:**  
- Isabella Ocampo  
- Maria Laura Tafur  

**Group:** C2566 SI2002-5730  

For the implementation of this project, the operating system used was **Windows 10**, the programming language was **Java**, and the main development tool was **IntelliJ IDEA 2025.1**. These tools provided a stable environment for coding, testing, and running the program, ensuring compatibility and efficiency during the implementation process.

## Program Description

This **Java program** implements the **General Algorithm for Eliminating Left Recursion** from a *Context-Free Grammar (CFG)*.
The program takes a **grammar as input** and produces an **equivalent grammar free of left recursion** — both **direct** and **indirect**.

---

## INSTRUCTIONS

## 1. Download and Structure

Make sure you have the following files located in the **same directory**:
- `EliminadorRecursion.java`
- `Gramatica.java`
- `Main.java`

---

## 2. Compilation

Open your **terminal** or **command prompt** in the project directory and compile both files:


javac Gramatica.java EliminadorRecursivo.java Main.java

Then run the main class, as follows:
java Main

## 3. Interactive Input

The program will request the following information:

- **Cases (n):** Total number of grammars to process.  
- **Non-Terminals (k):** For each case, the number of initial productions.  
- **Productions:** Enter each production in the format given by the input


---

## EXPLANATION

This **Java program** implements the **General Algorithm for Eliminating Left Recursion** from a Context-Free Grammar ($G$). The goal is to transform a grammar into an equivalent one that is suitable for top-down parsing methods (e.g., Predictive Parsers).

The algorithm is based on processing the non-terminals  in the strict **order of appearance** in the input, resolving indirect recursion before tackling direct recursion.

### 1. Algorithm Overview 

The entire process is driven by iterating through the non-terminals and, for each one, applying two sequential steps: substitution and immediate elimination.

### 2. Iterative Substitution (Eliminating Indirect Left Recursion)

For each current **Non-Terminal (NT)** (let's call it **A**), the algorithm reviews the NTs that precede it in the processing order.  
This step converts *indirect recursion* into *direct recursion*:

**Rule:**  
If the NT **A** has a production that starts with a preceding Non-Terminal (let's call it **B**) — for example, if  
`A → B γ`  
(where **γ** is a chain of symbols), this indicates **indirect left recursion**.  
This production must be **substituted**.

**Action:**  
The production containing **B** is replaced by all of **B**’s alternatives.  
The NT **B** is substituted with all its productions.  
The resulting production for **A** becomes:  
`A → δ γ`  
(where **δ** represents one of **B**’s alternatives).

**Purpose:**  
After this step, the NT **A** will only contain, at most, **direct recursion** (if `A → A α` exists).

---

### 3. Elimination of Direct Left Recursion

Once the NT **A** is free of indirect left recursion, the standard transformation is applied to eliminate the **direct recursion**.

#### Partition:
The productions of **A** are divided into two groups:
- **Recursive alternatives** → productions of the form `A → A α`
- **Non-recursive alternatives** → called *beta chains*

#### Transformation:
A new Non-Terminal (**Z**) is introduced, automatically generated by the program.

The original NT **A** is redefined to use the *beta chains* followed by the new NT **Z**
These equivalent pairs are then printed as the output.


## REFERENCES

- **Aho, Alfred V. et al.** (2006). *Compilers: Principles, Techniques, and Tools (2nd Edition).* Addison-Wesley Longman Publishing Co., Inc. **(Section 4.3.3: Elimination of Left Recursion)**

- https://www.youtube.com/watch?v=JsvC1mtE2nM


